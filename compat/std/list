#ifndef IGRIS_STD_LIST_H
#define IGRIS_STD_LIST_H

#include <igris/container/dlist.h>
#include <igris/util/ctrdtr.h>
#include <memory>

namespace std
{
    namespace detail
    {
        template <class T> class list_node
        {
        public:
            dlist_head head = DLIST_HEAD_INIT(head);
            T data = {};

        public:
            list_node() {}
            list_node(const T &data) : data(data) {}
            list_node(T &&data) : data(std::move(data)) {}

            T &value()
            {
                return data;
            }
            const T &value() const
            {
                return data;
            }

            dlist_head *get_head()
            {
                return &head;
            }
            const dlist_head *get_head() const
            {
                return &head;
            }
        };

        template <class T> class list_iterator
        {
            list_node<T> *node = nullptr;

        public:
            list_iterator() = default;
            list_iterator(list_node<T> *node) : node(node) {}

            list_iterator &operator++()
            {
                node = dlist_entry(node->get_head()->next, list_node<T>, head);
                return *this;
            }

            list_iterator operator++(int)
            {
                list_iterator tmp = *this;
                ++*this;
                return tmp;
            }

            list_iterator &operator--()
            {
                node = dlist_entry(node->get_head()->prev, list_node<T>, head);
                return *this;
            }

            list_iterator operator--(int)
            {
                list_iterator tmp = *this;
                --*this;
                return tmp;
            }

            T &operator*()
            {
                return node->value();
            }

            const T &operator*() const
            {
                return node->value();
            }

            T *operator->()
            {
                return &node->value();
            }

            const T *operator->() const
            {
                return &node->value();
            }

            bool operator==(const list_iterator &other) const
            {
                return node == other.node;
            }

            bool operator!=(const list_iterator &other) const
            {
                return node != other.node;
            }
        };
    };

    template <class T, class Alloc = std::allocator<detail::list_node<T>>>
    class list
    {
        dlist_head head = DLIST_HEAD_INIT(head);
        Alloc alloc;

    public:
        using iterator = detail::list_iterator<T>;
        using const_iterator = detail::list_iterator<const T>;

        void push_back(const T &data)
        {
            auto node = alloc.allocate(1);
            igris::constructor(node, data);
            dlist_add_tail(node->get_head(), &head);
        }

        void push_back(T &&data)
        {
            auto node = alloc.allocate(1);
            igris::constructor(node, std::move(data));
            dlist_add_tail(node->get_head(), &head);
        }

        T &back()
        {
            return dlist_entry(head.prev, detail::list_node<T>, head)->value();
        }

        const T &back() const
        {
            return dlist_entry(head.prev, detail::list_node<T>, head)->value();
        }

        void pop_back()
        {
            auto node = dlist_entry(head.prev, detail::list_node<T>, head);
            dlist_del(node->get_head());
            igris::destructor(node);
            alloc.deallocate(node, 1);
        }

        void push_front(const T &data)
        {
            auto node = alloc.allocate(1);
            igris::constructor(node, data);
            dlist_add(node->get_head(), &head);
        }

        void push_front(T &&data)
        {
            auto node = alloc.allocate(1);
            igris::constructor(node, std::move(data));
            dlist_add(node->get_head(), &head);
        }

        T &front()
        {
            return dlist_entry(head.next, detail::list_node<T>, head)->value();
        }

        const T &front() const
        {
            return dlist_entry(head.next, detail::list_node<T>, head)->value();
        }

        void pop_front()
        {
            auto node = dlist_entry(head.next, detail::list_node<T>, head);
            dlist_del(node->get_head());
            igris::destructor(node);
            alloc.deallocate(node, 1);
        }
    };
}

#endif
